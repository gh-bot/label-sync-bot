using Microsoft.Extensions.Logging;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Label.Synchronizer.Bot
{
    public static class GitHubApi
    {
        #region Name Constants

        public const string DATA         = "data";
        public const string NAME         = "name";
        public const string NODES        = "nodes";
        public const string LABEL        = "label";
        public const string TOKEN        = "token";
        public const string LABELS       = "labels";
        public const string BEARER       = "Bearer";
        public const string VIEWER       = "viewer";
        public const string ORIGINAL     = "original";
        public const string PAGEINFO     = "pageInfo";
        public const string ENDCURSOR    = "endCursor";
        public const string DATABASEID   = "databaseId";
        public const string HASNEXTPAGE  = "hasNextPage";
        public const string REPOSITORIES = "repositories";
        public const int    MAX_ITEMS_PER_TRANSACTION = 100;

        #endregion


        #region Configuration Keys
        
        public const string APP_ID      = "APP_ID";         // Application ID (required)
        public const string GITHUB_API  = "GITHUB_API";     // Url to GitHub API (default: https://api.github.com/)
        public const string PRIVATE_KEY = "PRIVATE_KEY";    // Private key generated by GitHub. Just the data, no formatting (required)  
        public const string USER_AGENT  = "USER_AGENT";     // User Agent

        #endregion


        #region GitHub Client

        public static HttpClient GetGitHubClient()
        {
            var id = int.Parse(Environment.GetEnvironmentVariable(APP_ID));
            var key = Environment.GetEnvironmentVariable(PRIVATE_KEY);
            var agent = Environment.GetEnvironmentVariable(USER_AGENT) ?? "Label.Synchronizer.Bot";

            var generator = new GitHubJwt.GitHubJwtFactory(
                new GitHubJwt.StringPrivateKeySource(key),
                new GitHubJwt.GitHubJwtFactoryOptions
                {
                    AppIntegrationId = id,
                    ExpirationSeconds = 555
                }
            );

            var jwtToken = generator.CreateEncodedJwtToken();
            var client = new HttpClient
            {
                BaseAddress = new Uri(Environment.GetEnvironmentVariable(GITHUB_API) ?? "https://api.github.com/")
            };

            client.DefaultRequestHeaders.Accept.ParseAdd("application/vnd.github.machine-man-preview+json");
            client.DefaultRequestHeaders.UserAgent.ParseAdd(agent);
            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(BEARER, jwtToken);

            return client; ;
        }

        public static async Task<JObject> GraphQL(this HttpClient github, string query)
        {
            var content = new StringContent(query, Encoding.UTF8);
            using var response = (await github.PostAsync("graphql", content)
                                              .ConfigureAwait(false))
                                              .EnsureSuccessStatusCode();

            var payload = await response.Content.ReadAsStringAsync()
                                                .ConfigureAwait(false);
            return JObject.Parse(payload);
        }

        #endregion


        #region Authentication

        public static async Task<HttpClient> AuthenticateAsInstallation(this HttpClient github, LabelEventPayload payload)
        {
            using (var content = new StringContent(string.Empty))
            {
                string method = $"/installations/{payload.InstallationId}/access_tokens";
                using var response = (await github.PostAsync(method, content))
                                                  .EnsureSuccessStatusCode();
                var json = await response.Content.ReadAsStringAsync();
                var obj = JObject.Parse(json);
                var token = obj[TOKEN]?.Value<string>();
                github.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(BEARER, token);

                return github;
            }
        }

        #endregion


        #region Marketplace

        public static async Task InitializeSubscribedPlan(this HttpClient github, LabelEventPayload payload, ILogger log)
        {
            string method = $"/marketplace_listing/accounts/{payload.OwnerId}";
            using var response = (await github.GetAsync(method));

            switch (response.StatusCode)
            {
                case System.Net.HttpStatusCode.OK:
                    var json = await response.Content.ReadAsStringAsync();
                    var data = JObject.Parse(json);
                    var rgxLimit   = new Regex(@"(p to )(\d+)( repositories)");
                    var rgxPrivate = new Regex(@"Private repositories");

                    foreach (var bullet in data["marketplace_purchase"]["plan"]["bullets"].Select(t => t.Value<string>()))
                    {
                        if (rgxLimit.IsMatch(bullet))
                        {
                            var match = Regex.Match(bullet, @"\d+").Value;
                            payload.Limit = int.Parse(match);
                            continue;
                        }
                        
                        if (rgxPrivate.IsMatch(bullet))
                        {
                            payload.IgnorePrivate = false;
                        }
                    }

                    if (log.IsEnabled(LogLevel.Trace)) log.LogTrace($"Marketplace Listing:\n {json}");
                    if (log.IsEnabled(LogLevel.Debug))
                    {
                        var plan = data["marketplace_purchase"]["plan"][NAME].Value<string>();
                        var allow = payload.IgnorePrivate ? "Public repositories only" : "Private Allowed";
                        var limit = int.MaxValue == payload.Limit ? "Unlimited repositories" : $"Limited to {payload.Limit.ToString()} repositories";
                        log.LogDebug($"Subscribed plan: '{plan}', {allow}, {limit}");
                    }

                    return;

                case System.Net.HttpStatusCode.NotFound:
                    return;
            }

            response.EnsureSuccessStatusCode();
        }

        #endregion


        #region Repository Enumerators

        public static async IAsyncEnumerable<JToken> GetNodes(this HttpClient github, LabelEventPayload payload)
        {
            var count = 0;
            var id = payload.RepositoryId;
            var limit = payload.Limit;

            var privacy = payload.IgnorePrivate ? ", privacy: PUBLIC" : string.Empty;
            var suffix = $", ownerAffiliations: OWNER{privacy}) {{ pageInfo {{ endCursor hasNextPage }} nodes {{ databaseId name label(name: \\\"{payload.LabelName}\\\") {{ name node_id:id color description }} }} }} }} }}\"}}";
            var query = $"{{\"query\":\"{{ viewer {{ repositories(first: {Math.Min(GitHubApi.MAX_ITEMS_PER_TRANSACTION, limit)}" + suffix;

            bool hasNextPage;
            var promise = github.GraphQL(query);
            do
            {
                // Wait for results
                JObject data = await promise;

                var repos   = data[DATA][VIEWER][REPOSITORIES];
                var page    = repos[PAGEINFO];
                hasNextPage = page[HASNEXTPAGE].Value<bool>();

                // If more data is available request it now
                if (hasNextPage)
                {
                    query = $"{{\"query\":\"{{ viewer {{ repositories(first: {GitHubApi.MAX_ITEMS_PER_TRANSACTION}, after: \\\"{page[ENDCURSOR].Value<string>()}\\\"" + suffix;
                    promise = github.GraphQL(query);
                }

                // Yield label info for each matching repository
                foreach (var node in repos[NODES])
                {
                    // Skip source repository
                    if (node[DATABASEID].Value<long>() == id) continue;

                    yield return node;

                    if (limit < ++count) yield break;
                }
            }
            while (hasNextPage);
        }

        public static async IAsyncEnumerable<(string repo, string label, string original)> MatchNodes(this HttpClient github, LabelEditedPayload payload)
        {
            var count = 0;
            var id = payload.RepositoryId;
            var limit = payload.Limit;

            var oldName = payload.ChangedNameFrom;
            var newName = payload.LabelName;
            var search = $"{newName} {oldName}";

            var privacy = payload.IgnorePrivate ? ", privacy: PUBLIC" : string.Empty;
            var suffix = $", ownerAffiliations: OWNER{privacy}) {{ pageInfo {{ endCursor hasNextPage }} nodes {{ databaseId name labels(first: 10, query: \\\"{search}\\\") {{ nodes {{ name color description }} }} }} }} }} }}\"}}";
            var query = $"{{\"query\":\"{{ viewer {{ repositories(first: {Math.Min(GitHubApi.MAX_ITEMS_PER_TRANSACTION, limit)}" + suffix;

            bool hasNextPage;
            var promise = github.GraphQL(query);
            do
            {
                // Wait for results
                JObject data = await promise;

                var repos   = data[DATA][VIEWER][REPOSITORIES];
                var page    = repos[PAGEINFO];
                hasNextPage = page[HASNEXTPAGE].Value<bool>();

                // If more data is available request it now
                if (hasNextPage)
                {
                    query = $"{{\"query\":\"{{ viewer {{ repositories(first: {GitHubApi.MAX_ITEMS_PER_TRANSACTION}, after: \\\"{page["endCursor"].Value<string>()}\\\"" + suffix;
                    promise = github.GraphQL(query);
                }

                // Yield label info for each matching repository
                foreach (var node in repos[NODES])
                {
                    // Skip source repository
                    if (node[DATABASEID].Value<long>() == id) continue;

                    // Scan and initialize found labels
                    
                    JToken source = null;
                    JToken target = null;

                    foreach (var label in node[LABELS][NODES]) 
                    {
                        var name = label[NAME].Value<string>();
                        if (name == newName) target = label;
                        if (name == oldName) source = label;
                    }

                    var tuple = 
                        (
                            repo:     node[NAME].Value<string>(), 
                            label:    null as string, 
                            original: null as string
                        );

                    // Assign found labels
                    if (null != source && null != target)
                    {
                        tuple.label    = target.Value<string>();
                        tuple.original = source[NAME].Value<string>();
                    }
                    else if (null != source)
                    {
                        tuple.label = source[NAME].Value<string>();
                    }
                    else if (null != target)
                    {
                        tuple.label = target[NAME].Value<string>();
                    }
                    
                    yield return tuple;
                    if (limit < ++count) yield break;
                }
            }
            while (hasNextPage);
        }

        #endregion
    }
}
