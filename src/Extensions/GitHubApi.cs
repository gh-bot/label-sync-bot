using Microsoft.Extensions.Logging;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Label.Synchronizer.Bot
{
    public static class GitHubApi
    {
        private static Regex RgxLimit = new Regex(@"(p to )(\d+)( repositories)");
        private static Regex RgxPrivate = new Regex(@"Private repositories");


        #region Name Constants

        public const string DATA = "data";
        public const string NAME = "name";
        public const string NODES = "nodes";
        public const string LABEL = "label";
        public const string TOKEN = "token";
        public const string LABELS = "labels";
        public const string BEARER = "Bearer";
        public const string VIEWER = "viewer";
        public const string ORIGINAL = "original";
        public const string PAGEINFO = "pageInfo";
        public const string ENDCURSOR = "endCursor";
        public const string DATABASEID = "databaseId";
        public const string HASNEXTPAGE = "hasNextPage";
        public const string REPOSITORIES = "repositories";
        public const int MAX_ITEMS_PER_TRANSACTION = 100;

        #endregion


        #region Configuration Keys

        public const string APP_ID = "APP_ID";         // Application ID (required)
        public const string GITHUB_API = "GITHUB_API";     // Url to GitHub API (default: https://api.github.com/)
        public const string PRIVATE_KEY = "PRIVATE_KEY";    // Private key generated by GitHub. Just the data, no formatting (required)  
        public const string USER_AGENT = "USER_AGENT";     // User Agent

        #endregion


        #region GitHub Client

        public static HttpClient GetGitHubClient()
        {
            var id = int.Parse(Environment.GetEnvironmentVariable(APP_ID));
            var key = Environment.GetEnvironmentVariable(PRIVATE_KEY);
            var agent = Environment.GetEnvironmentVariable(USER_AGENT) ?? "Label.Synchronizer.Bot";

            var generator = new GitHubJwt.GitHubJwtFactory(
                new GitHubJwt.StringPrivateKeySource(key),
                new GitHubJwt.GitHubJwtFactoryOptions
                {
                    AppIntegrationId = id,
                    ExpirationSeconds = 555
                }
            );

            var jwtToken = generator.CreateEncodedJwtToken();
            var client = new HttpClient
            {
                BaseAddress = new Uri(Environment.GetEnvironmentVariable(GITHUB_API) ?? "https://api.github.com/")
            };

            client.DefaultRequestHeaders.Accept.ParseAdd("application/vnd.github.machine-man-preview+json");
            client.DefaultRequestHeaders.UserAgent.ParseAdd(agent);
            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(BEARER, jwtToken);

            return client; ;
        }

        public static async Task<JObject> GraphQL(this HttpClient github, string query)
        {
            var content = new StringContent(query, Encoding.UTF8);
            using var response = (await github.PostAsync("graphql", content)
                                              .ConfigureAwait(false))
                                              .EnsureSuccessStatusCode();

            var payload = await response.Content.ReadAsStringAsync()
                                                .ConfigureAwait(false);
            return JObject.Parse(payload);
        }

        #endregion


        #region Authentication

        public static async Task<HttpClient> AuthenticateAsInstallation(this HttpClient github, LabelEventPayload payload)
        {
            using (var content = new StringContent(string.Empty))
            {
                string method = $"/installations/{payload.InstallationId}/access_tokens";
                using var response = (await github.PostAsync(method, content))
                                                  .EnsureSuccessStatusCode();
                var json = await response.Content.ReadAsStringAsync();
                var obj = JObject.Parse(json);
                var token = obj[TOKEN]?.Value<string>();
                github.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(BEARER, token);

                return github;
            }
        }

        #endregion


        #region Marketplace

        public static async Task InitializeSubscribedPlan(this HttpClient github, LabelEventPayload payload, ILogger log)
        {
            if (Exempt.Owners.Contains(payload.OwnerLogin)) return;

            string method = $"/marketplace_listing/accounts/{payload.OwnerId}";
            using var response = (await github.GetAsync(method));

            if (System.Net.HttpStatusCode.OK == response.StatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                var data = JObject.Parse(json);

                payload.IgnorePrivate = true;
                foreach (var bullet in data["marketplace_purchase"]["plan"]["bullets"].Select(t => t.Value<string>()))
                {
                    if (RgxLimit.IsMatch(bullet))
                    {
                        var match = Regex.Match(bullet, @"\d+").Value;
                        payload.Limit = int.Parse(match);
                        continue;
                    }

                    if (RgxPrivate.IsMatch(bullet))
                    {
                        payload.IgnorePrivate = false;
                    }
                }

                if (log.IsEnabled(LogLevel.Trace)) log.LogTrace($"Marketplace Listing:\n {json}");
                if (log.IsEnabled(LogLevel.Debug))
                {
                    var plan = data["marketplace_purchase"]["plan"][NAME].Value<string>();
                    var allow = payload.IgnorePrivate ? "Public repositories only" : "Private Allowed";
                    var limit = int.MaxValue == payload.Limit ? "Unlimited repositories" : $"Limited to {payload.Limit.ToString()} repositories";
                    log.LogDebug($"Subscribed plan: '{plan}', {allow}, {limit}");
                }
            }
            else
                response.EnsureSuccessStatusCode();
        }

        #endregion


        #region Repository Enumerators

        public static async IAsyncEnumerable<JToken> GetNodes(this HttpClient github, LabelEventPayload payload)
        {
            var count = 0;
            var id = payload.RepositoryId;
            var limit = payload.Limit;

            var privacy = payload.IgnorePrivate ? ", privacy: PUBLIC" : string.Empty;
            var suffix = $", ownerAffiliations: OWNER{privacy}) {{ pageInfo {{ endCursor hasNextPage }} nodes {{ databaseId name label(name: \\\"{payload.LabelName}\\\") {{ name node_id:id color description }} }} }} }} }}\"}}";
            var query = $"{{\"query\":\"{{ viewer {{ repositories(first: {Math.Min(GitHubApi.MAX_ITEMS_PER_TRANSACTION, limit)}" + suffix;

            bool hasNextPage;
            var promise = github.GraphQL(query);
            do
            {
                // Wait for results
                JObject data = await promise;

                var repos = data[DATA][VIEWER][REPOSITORIES];
                var page = repos[PAGEINFO];
                hasNextPage = page[HASNEXTPAGE].Value<bool>();

                // If more data is available request it now
                if (hasNextPage)
                {
                    query = $"{{\"query\":\"{{ viewer {{ repositories(first: {GitHubApi.MAX_ITEMS_PER_TRANSACTION}, after: \\\"{page[ENDCURSOR].Value<string>()}\\\"" + suffix;
                    promise = github.GraphQL(query);
                }

                // Yield label info for each matching repository
                foreach (var node in repos[NODES])
                {
                    // Skip source repository
                    if (node[DATABASEID].Value<long>() == id) continue;

                    yield return node;

                    if (limit < ++count) yield break;
                }
            }
            while (hasNextPage);
        }

        public static async IAsyncEnumerable<(string repo, string label, string original)> MatchNodes(this HttpClient github, LabelEditedPayload payload)
        {
            var count = 0;
            var id = payload.RepositoryId;
            var limit = payload.Limit;

            var oldName = payload.ChangedNameFrom;
            var newName = payload.LabelName;
            var search = $"{newName} {oldName}";

            var privacy = payload.IgnorePrivate ? ", privacy: PUBLIC" : string.Empty;
            var suffix = $", ownerAffiliations: OWNER{privacy}) {{ pageInfo {{ endCursor hasNextPage }} nodes {{ databaseId name labels(first: 10, query: \\\"{search}\\\") {{ nodes {{ name color description }} }} }} }} }} }}\"}}";
            var query = $"{{\"query\":\"{{ viewer {{ repositories(first: {Math.Min(GitHubApi.MAX_ITEMS_PER_TRANSACTION, limit)}" + suffix;

            bool hasNextPage;
            var promise = github.GraphQL(query);
            do
            {
                // Wait for results
                JObject data = await promise;

                var repos = data[DATA][VIEWER][REPOSITORIES];
                var page = repos[PAGEINFO];
                hasNextPage = page[HASNEXTPAGE].Value<bool>();

                // If more data is available request it now
                if (hasNextPage)
                {
                    query = $"{{\"query\":\"{{ viewer {{ repositories(first: {GitHubApi.MAX_ITEMS_PER_TRANSACTION}, after: \\\"{page["endCursor"].Value<string>()}\\\"" + suffix;
                    promise = github.GraphQL(query);
                }

                // Yield label info for each matching repository
                foreach (var node in repos[NODES])
                {
                    // Skip source repository
                    if (node[DATABASEID].Value<long>() == id) continue;

                    // Scan and initialize found labels

                    JToken source = null;
                    JToken target = null;

                    foreach (var label in node[LABELS][NODES])
                    {
                        var name = label[NAME].Value<string>();
                        if (name == newName) target = label;
                        if (name == oldName) source = label;
                    }

                    var tuple =
                        (
                            repo: node[NAME].Value<string>(),
                            label: null as string,
                            original: null as string
                        );

                    // Assign found labels
                    if (null != source && null != target)
                    {
                        tuple.label = target.Value<string>();
                        tuple.original = source[NAME].Value<string>();
                    }
                    else if (null != source)
                    {
                        tuple.label = source[NAME].Value<string>();
                    }
                    else if (null != target)
                    {
                        tuple.label = target[NAME].Value<string>();
                    }

                    yield return tuple;
                    if (limit < ++count) yield break;
                }
            }
            while (hasNextPage);
        }

        #endregion
    }
}
